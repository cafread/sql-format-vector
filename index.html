<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      main {
        overflow: hidden;
        display: flex;
        flex-direction: row;
        -webkit-align-items: stretch;
        align-items: stretch;
        height: calc(100% - 2px);
      }
      .input,
      .output {
        display: flex;
        -webkit-align-items: stretch;
        align-items: stretch;
        width: 50%;
        height: 100%;
      }
      .output {
        border-left: 2px solid #8dc63f;
      }
      textarea {
        width: 100%;
        padding: 20px;
        border: 0;
        box-sizing: border-box;
        resize: none;
        outline: none;
      }
      #testInfo {
        font-family: system-ui, sans-serif;
        margin: 0;
        padding: 2px;
        position: absolute;
        left: 40px;
        bottom: 20px;
        border: 2px solid #99c;
        background-color: azure;
        overflow: hidden;
        cursor: pointer;
        -webkit-user-select: none;  
           -moz-user-select: none;    
            -ms-user-select: none;      
                user-select: none;
      }
    </style>
    <link rel="stylesheet" href="lib/codemirror.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <link rel="shortcut icon" href="favicon.ico"/>
    <script src="lib/codemirror.js"></script>
    <script src="lib/codemirror-sql.js"></script>
    <script type="text/javascript" src="constants.js"></script>
    <script type="text/javascript" src="sqlFormatter.js"></script>
    <script type="text/javascript" src="unitTests.js"></script>
  </head>
  <body>
    <main>
      <section class="input">
        <textarea id="input" autofocus="true" wrap="off">/*Paste your code here, or just start writing!*/</textarea>
      </section>
      <section class="output">
        <textarea id="output" readonly="true" wrap="off">/*Formatted output will appear here*/</textarea>
      </section>
    </main>
    <div id="testInfo">Run Tests</div>
    <script>
      window.input = CodeMirror.fromTextArea(document.getElementById('input'), {
        mode: 'text/x-vector',
        indentWithTabs: false,
        smartIndent: false,
        lineNumbers: true,
        matchBrackets : true,
        autofocus: false,
        tabSize: 2
      });
      window.output = CodeMirror.fromTextArea(document.getElementById('output'), {
        mode: 'text/x-vector',
        indentWithTabs: false,
        smartIndent: false,
        lineNumbers: true,
        matchBrackets : true,
        autofocus: false,
        tabSize: 2
      });
      function format() {
        let inp = input.doc.getValue();
        let endsWithSc = inp.replace(/\s/gm, '').slice(-1) === ';';
        let queries = parseThenSplit(inp);
        for (let q of queries.filter(v => !queryCache.hasOwnProperty(v))) queryCache[q] = sqlFormatter.format(q + ';', {language: 'vector', uppercase: true}).replace(/\n+$/, '');
        let out = queries.map(q => queryCache[q]).join('\n');
        out =  endsWithSc ? out : out.slice(0, out.length - 1).replace(/\n$/, '');
        output.doc.setValue(out);
        gcCache(queries);
      }
      function gcCache (active=[]) {
        let liveKeys = Object.keys(queryCache);
        if ((liveKeys.length - active.length) < 200) return; // Don't bother running GC process if cache is small
        // So that editing continuously doesn't use all the memory on the system run garbage collection
        let keepKeys = (['', ';', '\n']).concat(active); // Keys in the cache we want to preserve
        // If there was a lot of concern about repeated queries, this could be a Set rather than an Array
        for (let key of liveKeys.filter(k => keepKeys[k] === undefined)) delete queryCache[key];
      }
      // Avoid excessive calls while typing by debouncing input change
      function debounce (callback, time = 200) {
        let interval;
        return (...args) => {
          clearTimeout(interval);
          interval = setTimeout(() => {interval = null; callback(...args);}, time);
        };
      }
      var dbf = debounce(format, 40);
      CodeMirror.on(input, 'change', dbf);
      
      const testInfo = document.getElementById("testInfo");
      testInfo.addEventListener("click", unitTest);
      
      // Split incoming SQL by ; where it is not commented, part of a regex or string literal
      // Replace block comments with line comments when neither part of a string "/' nor commented
      function parseThenSplit (code) {
        // State
        let isInRegExp  = false;
        let isInString  = false;
        let terminator  =  null; // To hold the string terminator
        let escape      = false; // Last char was an escape
        let isInComment = false;
        let c = code.split('');  // Input
        let o = [];              // Output
        let querySepar = '\n;split_here;\n';
        for (let i = 0; i < c.length; i++) {
          if (isInString) {  // Handle string literal case
            if (c[i] === terminator && escape === false) {
              isInString = false;
              o.push(c[i]);
            } else if (c[i] === '\\') { // Escape
              escape = true;
            } else {
              escape = false;
              o.push(c[i]); 
            }
          } else if (isInRegExp) { // Regular expression case
            if (c[i] === '/' && escape === false) {
              isInRegExp = false;
              o.push(c[i]);
            } else if (c[i] === '\\') {
              escape = true;
            } else { 
              escape = false;
              o.push(c[i]);
            }
          } else if (isInComment) { // Comment case
            if (c[i] === '*' && c[i+1] === '/') {
              isInComment = false;
              o.push('\n');
              i++;
            } else if (c[i] === '\n') {
              o.push('\n-- ');
            } else {
              o.push(c[i]);
            }
          } else { // Not in a literal
            if (c[i] === '-' && c[i+1] === '-') { // Single line comment
              o.push('\n--');
              if (c[i+2] !== ' ' && c[i+2] !== '\n') o.push(' '); // Space after comments if not existing already
              i = i + 2;
              while (c[i] !== '\n' && c[i] !== undefined) {
                o.push(c[i]);
                i++; // End or new line
              };
              o.push('\n');
            } else if (c[i] === '/' && c[i+1] === "*") { // Start comment
              isInComment = true;
              o.push('\n--');
              if (c[i+2] !== ' ' && c[i+2] !== '\n') o.push(' '); // Add a space per spec if it's missing
              i++; // Skip past comment chars
            } else if (c[i] === '/') { // Start regexp literal
              isInRegExp = true;
              o.push(c[i]);
            } else if (c[i] === "'" || c[i] === '"') { // String literal
              isInString = true;
              o.push(c[i]);
              terminator = c[i];
            } else { // Code
              if (c[i] === ';') {
                o.push(querySepar);
              } else {
                o.push(c[i]);
              }
            }
          }
        }
        o = o.join('')
             .replace(/ +\n/g, '\n')
             .replaceAll('-- custom fields to be added here', '--custom fields to be added here')
             .split(querySepar) // Split into queries
             .filter(v => v.replaceAll(/\s/g, '').length > 1) // Only real queries 
             .map(q => q.replace(/;+$/, '')); // Trim any trailing ;
        return o;
      }
    </script>
  </body>
</html>
